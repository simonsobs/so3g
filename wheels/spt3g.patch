diff -urN spt3g_software_orig/calibration/python/bolopropertiesutils.py spt3g_software/calibration/python/bolopropertiesutils.py
--- spt3g_software_orig/calibration/python/bolopropertiesutils.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/calibration/python/bolopropertiesutils.py	2021-11-12 00:31:41.087126296 -0800
@@ -1,5 +1,5 @@
-from spt3g.calibration import BolometerProperties
-from spt3g import core
+from .libcalibration import BolometerProperties
+from .. import core
 import math
 
 __all__ = ['SplitByProperty', 'SplitByBand', 'SplitTimestreamsByBand',
diff -urN spt3g_software_orig/calibration/python/build_cal_frames.py spt3g_software/calibration/python/build_cal_frames.py
--- spt3g_software_orig/calibration/python/build_cal_frames.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/calibration/python/build_cal_frames.py	2021-11-12 00:32:24.338629413 -0800
@@ -1,6 +1,6 @@
-from spt3g import core
-from spt3g.calibration import BolometerProperties, BolometerPropertiesMap
-from spt3g.calibration import PointingProperties, PointingPropertiesMap
+from .. import core
+from .libcalibration import BolometerProperties, BolometerPropertiesMap
+from .libcalibration import PointingProperties, PointingPropertiesMap
 import numpy, scipy.stats, os, re
 
 '''
@@ -24,13 +24,13 @@
     - Band Calibration (Key: 'BoloBands')
     - Physical Name Data (Key: 'PhysicalBoloIDs')
     '''
-    
+
     def __init__(self, drop_original_frames=True, fiducial_detectors=[],
                  bpm_name='NominalBolometerProperties', use_bpm_pointing=False):
         '''
         If drop_original_frames is True, will drop all input Calibration frames.
 
-        If fiducial_detectors is set, will use the average of the position[s] of 
+        If fiducial_detectors is set, will use the average of the position[s] of
         whatever detector[s] are specified to center each set of relative offsets
         encountered (NB: this recentering is done in a Cartesian way). If it is
         *not* specified, five detectors near the middle of the focal plane present
@@ -62,7 +62,7 @@
                 gooddata = numpy.asarray(data)[numpy.isfinite(data)]
                 if len(gooddata) == 1:
                     return gooddata[0]
-                return numpy.median(scipy.stats.sigmaclip(gooddata, 
+                return numpy.median(scipy.stats.sigmaclip(gooddata,
                                                           low=2.0, high=2.0)[0])
 
             if len(self.fiducial_detectors) == 0:
@@ -106,7 +106,7 @@
                     p.wafer_id = self.props[bolo]['wafer_id']
                 if 'pixel_type' in self.props[bolo]:
                     p.pixel_type = self.props[bolo]['pixel_type']
-                
+
                 boloprops[bolo] = p
 
             cframe = core.G3Frame(core.G3FrameType.Calibration)
@@ -300,7 +300,7 @@
     Expects to be passed frames from:
     - Az tilt fit parameters (Keys: 'tiltAngle', 'tiltHA', 'tiltLat', 'tiltMag')
     '''
-    
+
     def __init__(self, drop_original_frames=True):
         '''
         If drop_original_frames is True, will drop all input Calibration frames.
@@ -321,10 +321,10 @@
 
             if 'tiltHA' in self.props:
                 p['tiltHA'] = self.props['tiltHA']
-            
+
             if 'tiltMag' in self.props:
                 p['tiltMag'] = self.props['tiltMag']
-            
+
             if 'tiltAngle' in self.props:
                 p['tiltAngle'] = self.props['tiltAngle']
 
diff -urN spt3g_software_orig/calibration/python/__init__.py spt3g_software/calibration/python/__init__.py
--- spt3g_software_orig/calibration/python/__init__.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/calibration/python/__init__.py	2021-11-12 00:33:03.614175334 -0800
@@ -1,5 +1,5 @@
-from spt3g.core.load_pybindings import load_pybindings
-load_pybindings(__name__, __path__)
+# Import all our compiled tools
+from .libcalibration import *
 
 from . import build_cal_frames
 
diff -urN spt3g_software_orig/calibration/src/python.cxx spt3g_software/calibration/src/python.cxx
--- spt3g_software_orig/calibration/src/python.cxx	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/calibration/src/python.cxx	2021-11-12 00:35:00.456810357 -0800
@@ -2,15 +2,14 @@
 
 namespace bp = boost::python;
 
-BOOST_PYTHON_MODULE(calibration)
+BOOST_PYTHON_MODULE(libcalibration)
 {
 	// Python bindings dependencies
-	bp::import("spt3g.core");
+	bp::import("spt3g.libcore");
 
 	// Disable noise in doc strings
 	bp::docstring_options docopts(true, true, false);
 
 	// Python bindings for this module
-	G3ModuleRegistrator::CallRegistrarsFor("calibration");
+	G3ModuleRegistrator::CallRegistrarsFor("libcalibration");
 }
-
diff -urN spt3g_software_orig/core/python/dataextensions.py spt3g_software/core/python/dataextensions.py
--- spt3g_software_orig/core/python/dataextensions.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/dataextensions.py	2021-11-12 00:35:51.148212409 -0800
@@ -1,4 +1,4 @@
-from spt3g.core import G3Bool, G3Int, G3Double, G3String
+from .libcore import G3Bool, G3Int, G3Double, G3String
 
 __all__ = []
 
diff -urN spt3g_software_orig/core/python/docparser.py spt3g_software/core/python/docparser.py
--- spt3g_software_orig/core/python/docparser.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/docparser.py	2021-11-12 00:36:08.168010951 -0800
@@ -1,5 +1,5 @@
 import sys, inspect, re, textwrap
-from spt3g.core import G3Module, G3FrameObject
+from .libcore import G3Module, G3FrameObject
 
 def format_doc(x, simple=False):
     """
@@ -39,12 +39,12 @@
         mod = __import__(module_path)
         if '.' in module_path and hasattr(mod, module_path.split('.')[-1]):
             mod = mod.__dict__[module_path.split('.')[-1]]
-    
+
     except ImportError as e:
         print('Could not import module %s:' % module_path)
         print(e)
         sys.exit(1)
-    
+
 
     def format_object(modname, x):
         name = '%s.%s' % (modname, x)
@@ -58,7 +58,7 @@
         return '\n\n*Definition:*\n        ``%s``\n' % argdef.strip()
     def add_str(s0, s1):
         return s0 + s1 + '\n'
-    
+
     #G3Module documentation
     anti_recursion_protector = []
     def iterate_through_mod(mod, modname):
@@ -83,7 +83,7 @@
                 anti_recursion_protector.append(itemname)
             except:
                 continue
-            
+
             subclasstest = False
             try:
                 subclasstest = issubclass(obj, G3Module)
@@ -128,7 +128,7 @@
                 mod_dict.update(iterate_through_mod(obj, itemname))
         return mod_dict
 
-    #Useful Function documentation    
+    #Useful Function documentation
     other_anti_recursion_protector = []
     def iterate_through_func(mod, modname):
         mod_dict = {}
@@ -164,7 +164,7 @@
                         tmp_str = format_doc(obj)
                         out_str = out_str + tmp_str
                     if subclasstest:
-                        out_str = out_str 
+                        out_str = out_str
                 try:
                     out_str = add_str(out_str, format_arguments(x, inspect.formatargspec(*inspect.getargspec(obj))))
                 except:
@@ -175,7 +175,7 @@
                 mod_dict.update(iterate_through_func(obj, itemname))
         return mod_dict
 
-    #Frame Object documentation    
+    #Frame Object documentation
     other_other_anti_recursion_protector = []
     def iterate_through_frame_object(mod, modname):
         mod_dict = {}
diff -urN spt3g_software_orig/core/python/frameextensions.py spt3g_software/core/python/frameextensions.py
--- spt3g_software_orig/core/python/frameextensions.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/frameextensions.py	2021-11-12 00:36:54.468082894 -0800
@@ -1,4 +1,4 @@
-from spt3g.core import G3Frame, G3FrameType
+from .libcore import G3Frame, G3FrameType
 
 @staticmethod
 def str_to_frame_types(types):
diff -urN spt3g_software_orig/core/python/g3decorators.py spt3g_software/core/python/g3decorators.py
--- spt3g_software_orig/core/python/g3decorators.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/g3decorators.py	2021-11-12 00:37:19.043445403 -0800
@@ -1,4 +1,4 @@
-from spt3g.core import G3FrameType
+from .libcore import G3FrameType
 from copy import copy
 import inspect
 import textwrap
@@ -7,10 +7,10 @@
 def get_function_signature(f, replacement_kwargs = None):
     '''
     gets the function signature of f.
-     
-    if replacement_kwargs is supplied replaces the default values with 
+
+    if replacement_kwargs is supplied replaces the default values with
      the ones in replacement_kwargs
-    
+
     '''
     args = inspect.getargspec(f)
     name = f.__name__
@@ -50,7 +50,7 @@
     This is a decorator for use with G3Modules written as functions.  It enables
     a function to use cached values from other types of frames in the processing
     of a frame.
-    
+
     To make that confusing sentence clearer with an example, in a lot of cases
     we want to have a module that works on Scan frames, but have access to the
     BolometerProperties.  This decorator allows you to specify the information
@@ -70,7 +70,7 @@
     Key specifies the name of the argument that we pass the infromation to in
     the decorated function.  If the decorated function is called with Key as an
     argument it will overwrite the value specified in the decorator.
-       
+
     Value specifies the default path to look for the cached data.  It will
     search all of the frames that do not have the frame type 'type' for a key
     with that value.  This can be overridden when calling the decorated
@@ -97,7 +97,7 @@
             doc_append += '    %s = "%s"\n' % ( k, v )
 
         class WrappedFunc:
-            def __init__(self, *args, **kwargs): 
+            def __init__(self, *args, **kwargs):
                 self.args = args
                 self.kwargs = kwargs
 
diff -urN spt3g_software_orig/core/python/G3File.py spt3g_software/core/python/G3File.py
--- spt3g_software_orig/core/python/G3File.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/G3File.py	2021-11-12 00:38:01.535843483 -0800
@@ -1,6 +1,6 @@
-from spt3g.core import G3Reader
+from .libcore import G3Reader
 
-class G3File(object): 
+class G3File(object):
 	'''Iterable class for G3 files, as created by G3Writer. Loop through frames by doing something like:
 	f = core.G3File('/path/to/file.g3')
 	for frame in f:
diff -urN spt3g_software_orig/core/python/G3FileStager.py spt3g_software/core/python/G3FileStager.py
--- spt3g_software_orig/core/python/G3FileStager.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/G3FileStager.py	2021-11-12 00:38:36.018037640 -0800
@@ -16,20 +16,20 @@
 import subprocess
 import re
 
-from spt3g.core import G3Reader, G3Writer, G3FrameType
-from spt3g.core import g3logging as logging
+from .libcore import G3Reader, G3Writer, G3FrameType
+from .libcore import g3logging as logging
 
 class GridFTPStager(object):
     """
     Provides to subprocess calls to stage files in and out using GridFTP
-    
+
     Handles ftp:// and gsiftp:// URLs
-    
+
     .. note:: GridFTP requires that you have a proxy certificate either in the
               standard location or in the location specified by the environment
-              variable X509_USER_PROXY. See the `Globus Toolkit documentation 
+              variable X509_USER_PROXY. See the `Globus Toolkit documentation
               <http://toolkit.globus.org/toolkit/docs/4.1/admin/docbook/gtadmin-env-var.html#id2565277>`_
-              for more information. You will also need to 
+              for more information. You will also need to
               `obtain a user certificate `_.
     """
     def __init__(self, globus_url_copy='globus-url-copy', options=['-nodcau', '-rst', '-cd']):
@@ -40,50 +40,50 @@
     def transfer_file_in(self, url, local_path):
         """
         Transfers files to local directory from remote site
-        
+
         Keyword arguments:
         url -- remote location of the file as a URL (no default)
         local_path -- path to local directory where file show be put (no default)
         """
-        local_path = os.path.join(os.path.abspath(local_path), 
+        local_path = os.path.join(os.path.abspath(local_path),
                                   os.path.basename(url))
-        proc = subprocess.Popen([self.globus_url_copy] + self.options + [url, 
-                                 'file://'+os.path.abspath(local_path)], 
+        proc = subprocess.Popen([self.globus_url_copy] + self.options + [url,
+                                 'file://'+os.path.abspath(local_path)],
                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         stdout, stderr = proc.communicate()
         if proc.returncode != 0:
             logging.log_fatal("globus-url-copy failed with status %d: %s" % \
-                              (proc.returncode, stderr.strip()), 
+                              (proc.returncode, stderr.strip()),
                               unit="GridFTPStager")
         else:
-            logging.log_info("Download finished: %s to %s" % (url, local_path), 
+            logging.log_info("Download finished: %s to %s" % (url, local_path),
                              unit="GridFTPStager")
         return local_path
-    
+
     def transfer_file_out(self, local_path, url):
         """
         Transfers files to local directory from remote site
-        
+
         Keyword arguments:
         local_path -- path to local directory where file is located (no default)
         url -- remote location of the file as a URL (no default)
         """
         proc = subprocess.Popen([self.globus_url_copy] + self.options + \
-                                ['file://'+os.path.abspath(local_path), url], 
+                                ['file://'+os.path.abspath(local_path), url],
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         stdout, stderr = proc.communicate()
         if proc.returncode != 0:
             logging.log_fatal("globus-url-copy failed with status %d: %s" % \
-                              (proc.returncode, stderr.strip()), 
+                              (proc.returncode, stderr.strip()),
                               unit="GridFTPStager")
         else:
-            logging.log_info("Upload finished: %s to %s" % (local_path, url), 
+            logging.log_info("Upload finished: %s to %s" % (local_path, url),
                              unit="GridFTPStager")
 
 class HTTPStager(object):
     """
-    Provides to subprocess calls to stage files in and out using http. 
-    
+    Provides to subprocess calls to stage files in and out using http.
+
     Handles http://, https://, ftp://, and file:// URLs
     """
     def __init__(self, blocksize=2**16, ssl=None):
@@ -94,7 +94,7 @@
         """
         urlopen() doesn't support inline auth. Strip it out and
         construct the appropriate header by hand.
-        
+
         Keyword arguments:
         url -- url with authenication tokens
         """
@@ -114,7 +114,7 @@
     def transfer_file_in(self, url, local_path):
         """
         Transfers files to local directory from remote site
-        
+
         Keyword arguments:
         url -- remote location of the file as a URL (no default)
         local_path -- path to local directory where file show be put (no default)
@@ -127,7 +127,7 @@
         # copy the file
         if parsed_url.scheme == "file":
             if parsed_url.netloc != "":
-                logging.log_fatal("%s is not a valid URI (file:// URIs must use absolute paths)" % url, 
+                logging.log_fatal("%s is not a valid URI (file:// URIs must use absolute paths)" % url,
                                   unit="HTTPStager")
             input_path = parsed_url.path
             logging.log_info("Copying file %s to %s" % (input_path, output_path),
@@ -136,7 +136,7 @@
             logging.log_info("File copied: %s to %s" % (input_path, output_path),
                              unit="HTTPStager")
         else:
-            logging.log_info("Downloading %s to %s" % (url, output_path), 
+            logging.log_info("Downloading %s to %s" % (url, output_path),
                              unit="HTTPStager")
             f = None
             output_file = None
@@ -151,12 +151,12 @@
                     output_file.write(block)
                     if len(block) < self.blocksize:
                         break
-                logging.log_info("Download finished: %s to %s" % (url, local_path), 
+                logging.log_info("Download finished: %s to %s" % (url, local_path),
                                  unit="HTTPStager")
             except Exception as e:
                 if os.path.exists(local_path):
                     os.remove(local_path)
-                logging.log_fatal("Downloading %s: %s" % (url, str(e)), 
+                logging.log_fatal("Downloading %s: %s" % (url, str(e)),
                                   unit="HTTPStager")
             finally:
                 if f is not None:
@@ -164,30 +164,30 @@
                 if output_file is not None:
                     output_file.close()
         return output_path
-    
+
     def transfer_file_out(self, local_path, url):
         """
-        Transfers files to local directory from remote site. Only works for file:// handle. 
+        Transfers files to local directory from remote site. Only works for file:// handle.
         Will we ever have an HTTP drop box? Else HTTP, etc. will not be supported
-        
+
         Keyword arguments:
         local_path -- path to local directory where file is located (no default)
         url -- remote location of the file as a URL (no default)
         """
         parsed_url = urlparse.urlparse(url, scheme="file") # use "file" as the default scheme
         if parsed_url[0] not in ["http", "https", "ftp", "file"]:
-            logging.log_fatal("Cannot handle URL scheme \"%s\": %s" % (parsed_url[0], url), 
+            logging.log_fatal("Cannot handle URL scheme \"%s\": %s" % (parsed_url[0], url),
                               unit="HTTPStager")
         # copy the file
         if parsed_url[0] == "file":
             output_path = parsed_url[2]
             if parsed_url.netloc != "":
-                logging.log_fatal("%s is not a valid URI (file:// URIs must use absolute paths)" % url, 
+                logging.log_fatal("%s is not a valid URI (file:// URIs must use absolute paths)" % url,
                                   unit="HTTPStager")
-            logging.log_info("Copying file %s to %s" % (local_path, output_path), 
+            logging.log_info("Copying file %s to %s" % (local_path, output_path),
                              unit="HTTPStager")
             shutil.copyfile(local_path, output_path)
-            logging.log_info("File copied: %s to %s" % (local_path, output_path), 
+            logging.log_info("File copied: %s to %s" % (local_path, output_path),
                              unit="HTTPStager")
         else:
             logging.log_fatal("Can't upload to %s" % url.scheme)
@@ -195,13 +195,13 @@
 class G3FileStager(object):
     """
     Staging mechanism class.
-    
+
     Gets the input, output, and (optionally) temporary directory paths.
     Decides which transfer protocol to use depending on the file path.
-    Provides function to stage files in and out. 
+    Provides function to stage files in and out.
     """
-    def __init__(self, input_path=None, output_path=None, 
-                 tmp_dir=None, simulation=False, 
+    def __init__(self, input_path=None, output_path=None,
+                 tmp_dir=None, simulation=False,
                  cleanup=True):
         if input_path is None:
             logging.log_fatal("Need to provide an input file")
@@ -223,45 +223,45 @@
         self.cleanup=cleanup
         self.local_input_files = []
 
-    
+
     def stage_files_in(self):
         if isinstance(self.input_path, list):
             local_files = [self.stage_file_in(f) for f in self.input_path]
         else:
             local_files = [self.stage_file_in(self.input_path)]
         return local_files
-        
+
     def stage_file_in(self, input_file):
         return self.determine_protocol(input_file).transfer_file_in(input_file, self.tmp_dir)
-        
+
     def stage_file_out(self, local_output_filename, remote_output_filename):
         self.determine_protocol(remote_output_filename).transfer_file_out(local_output_filename, remote_output_filename)
         if self.cleanup:
             os.remove(local_output_filename)
-        
+
     def get_local_g3_filenames(self):
-        if len(self.local_input_files) == 0: 
+        if len(self.local_input_files) == 0:
             self.local_input_files = self.stage_files_in()
         return [f for f in self.local_input_files if ".g3" in os.path.basename(f)]
-        
+
     def get_remote_g3_output_filename(self):
         remote_outfiles = [f for f in self.output_path if ".g3" in os.path.basename(f)]
         if len(remote_outfiles) > 1:
             logging.log_warn("Ignoring multiple output .g3 files. Using %s as the output file name" % remote_outfiles[0],
                              unit="G3FileStager")
         if len(remote_outfiles) < 1:
-            logging.log_fatal("Please provide a .g3 output file.", 
+            logging.log_fatal("Please provide a .g3 output file.",
                               unit="G3FileStager")
         return remote_outfiles[0]
-    
+
     def get_local_output_filename(self, filename):
         return os.path.join(self.tmp_dir, os.path.basename(filename))
-        
+
     def get_local_nong3_filenames(self):
-        if len(self.local_input_files) == 0: 
+        if len(self.local_input_files) == 0:
             self.local_input_files = self.stage_files_in()
         return [f for f in self.local_input_files if ".g3" not in os.path.basename(f)]
-        
+
     def determine_protocol(self, filename):
         protocol_id = urlparse.urlparse(filename).scheme
         if protocol_id in ["gsiftp", "ftp"]:
@@ -270,7 +270,7 @@
             return HTTPStager()
         else:
             raise NotImplementedError("The %s protocal is not supported" % protocol_id)
-    
+
     def try_to_make_scratch_dir(self, basename, fullname):
         if not os.path.isdir(basename):
             return False
@@ -304,7 +304,7 @@
                 staging_directory = os.getcwd()
                 logging.log_info("Cannot find a suitable scratch directory on this machine; falling back to the current working directory (%s). If this is not what you want, set a different path with dataio.set_local_scratch_dir(path)." % staging_directory, unit="G3Reader")
             return staging_directory
-    
+
 @core.indexmod
 class G3URLReader(object):
     """
@@ -314,12 +314,12 @@
         self.infiles = stager.get_local_g3_filenames()
         print(self.infiles)
         self.reader = G3Reader(self.infiles.pop(0))
-    
+
     def __call__(self, frame):
         assert(frame is None) # Needed for driving module
         outframe = self.reader(None)
         if len(outframe) == 0:
-            while len(self.infiles) > 0 and len(outframe) == 0: 
+            while len(self.infiles) > 0 and len(outframe) == 0:
                 self.reader = G3Reader(self.infiles.pop(0))
                 outframe = self.reader(None)
             return outframe
@@ -336,11 +336,11 @@
         self.remote_outfile = stager.get_remote_g3_output_filename()
         self.local_outfile = stager.get_local_output_filename(self.remote_outfile)
         self.writer = G3Writer(self.local_outfile)
-    
+
     def __call__(self, frame):
         if frame.type != G3FrameType.EndProcessing:
             self.writer(frame)
         else:
             del self.writer
             self.stager.stage_files_out(self.local_outfile, self.remote_outfile)
-            
+
diff -urN spt3g_software_orig/core/python/g3logging.py spt3g_software/core/python/g3logging.py
--- spt3g_software_orig/core/python/g3logging.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/g3logging.py	2021-11-12 00:38:55.014969635 -0800
@@ -1,4 +1,4 @@
-from spt3g.core import G3Logger, G3LogLevel
+from .libcore import G3Logger, G3LogLevel
 import traceback
 from functools import reduce
 
@@ -27,12 +27,12 @@
 def log_fatal(*args, **kwargs):
     '''
     Behaves like print but with logging behavior as described in logging.rst
-    
+
     The only kwarg that it recognizes is "unit", for setting the logging unit.
     '''
     message = reduce(lambda a,b: '%s %s' % ( str(a), str(b)), args)
     unit = kwargs.get('unit')
-    unit = unit if unit != None else 'Python'    
+    unit = unit if unit != None else 'Python'
     tb = traceback.extract_stack(limit=2)[0]
     G3Logger.global_logger.log(G3LogLevel.LOG_FATAL, unit, tb[0], tb[1],
         tb[2], message)
@@ -42,7 +42,7 @@
     '''
     Set log level to the requested level. If unit is not None, set the
     log level for the given logging unit only.
-    
+
     Example: core.set_log_level(core.G3LogLevel.LOG_DEBUG, 'GCPMuxDataDecoder')
     '''
 
diff -urN spt3g_software_orig/core/python/__init__.py spt3g_software/core/python/__init__.py
--- spt3g_software_orig/core/python/__init__.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/__init__.py	2021-11-12 00:41:18.454442956 -0800
@@ -1,7 +1,7 @@
-from spt3g.core.load_pybindings import load_pybindings
-load_pybindings(__name__, __path__)
+# Import all our compiled tools
+from .libcore import *
 
-from spt3g.core.g3logging import log_trace, log_debug, log_info, log_notice, log_warn, log_error, log_fatal, set_log_level
+from .g3logging import log_trace, log_debug, log_info, log_notice, log_warn, log_error, log_fatal, set_log_level
 
 import atexit
 def fix_logging_crash():
@@ -11,22 +11,22 @@
 atexit.register(fix_logging_crash)
 del fix_logging_crash
 
-from spt3g.core.G3File import G3File
-from spt3g.core.modconstruct import pipesegment, indexmod, pipesegment_nodoc
-from spt3g.core.funcconstruct import usefulfunc
+from .G3File import G3File
+from .modconstruct import pipesegment, indexmod, pipesegment_nodoc
+from .funcconstruct import usefulfunc
 try:
-	from spt3g.core.parse_pipeline_graph import plot_frame_processing_info
+	from .parse_pipeline_graph import plot_frame_processing_info
 except ImportError:
 	pass
 try:
-	from spt3g.core.multiprocess import Subproc
+	from .multiprocess import Subproc
 except ImportError:
 	pass
-from spt3g.core.util import *
+from .util import *
 
-from spt3g.core.docparser import *
-from spt3g.core.dataextensions import *
-from spt3g.core.frameextensions import *
-from spt3g.core.timestreamextensions import *
+from .docparser import *
+from .dataextensions import *
+from .frameextensions import *
+from .timestreamextensions import *
 
-from spt3g.core.g3decorators import cache_frame_data, scan_func_cache_data
+from .g3decorators import cache_frame_data, scan_func_cache_data
diff -urN spt3g_software_orig/core/python/load_pybindings.py spt3g_software/core/python/load_pybindings.py
--- spt3g_software_orig/core/python/load_pybindings.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/load_pybindings.py	1969-12-31 16:00:00.000000000 -0800
@@ -1,30 +0,0 @@
-import platform,sys
-
-if platform.system().startswith('freebsd') or platform.system().startswith('FreeBSD'):
-	# C++ modules are extremely fragile when loaded with RTLD_LOCAL,
-	# which is what Python uses on FreeBSD by default, and maybe other
-	# systems. Convince it to use RTLD_GLOBAL.
-
-	# See thread by Abrahams et al:
-	# http://mail.python.org/pipermail/python-dev/2002-May/024074.html
-	sys.setdlopenflags(0x102)
-
-lib_prefix = "libspt3g-"
-
-if platform.system().startswith('Darwin'):
-    # OSX compatibility requires .dylib suffix
-    lib_suffix = ".dylib"
-else:
-    lib_suffix = ".so"
-
-def load_pybindings(name, path):
-	import imp, os, sys
-	mod = sys.modules[name]
-	p = os.path.split(path[0])
-	m = imp.load_dynamic(name, p[0] + "/" + lib_prefix + p[1] + lib_suffix)
-	sys.modules[name] = mod # Don't override Python mod with C++
-
-	for (k,v) in m.__dict__.items():
-		if not k.startswith("_"):
-			mod.__dict__[k] = v
-
diff -urN spt3g_software_orig/core/python/modconstruct.py spt3g_software/core/python/modconstruct.py
--- spt3g_software_orig/core/python/modconstruct.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/modconstruct.py	2021-11-12 00:45:40.526165023 -0800
@@ -1,6 +1,6 @@
-from spt3g.core import G3Module, G3Pipeline, G3PipelineInfo, G3Frame, G3FrameType, G3Time, G3ModuleConfig, log_fatal
+from .libcore import G3Module, G3Pipeline, G3PipelineInfo, G3Frame, G3FrameType, G3Time, G3ModuleConfig, log_fatal
 try:
-    from spt3g.core import multiprocess
+    from . import multiprocess
     multiproc_avail = True
 except ImportError:
     multiproc_avail = False
@@ -131,7 +131,7 @@
 
 class _add_pipeline_info(G3Module):
     def __init__(self):
-        from spt3g import version
+        from .. import version
         import socket, getpass
 
         G3Module.__init__(self)
@@ -208,7 +208,7 @@
     name = self.nameprefix + name
 
     # Record module configuration for root objects
-    if self.nameprefix == '': 
+    if self.nameprefix == '':
         modconfig = G3ModuleConfig()
         modconfig.instancename = name
         modconfig.modname = '%s.%s' % (callable.__module__, callable_name)
diff -urN spt3g_software_orig/core/python/multiprocess.py spt3g_software/core/python/multiprocess.py
--- spt3g_software_orig/core/python/multiprocess.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/multiprocess.py	2021-11-12 00:46:09.295605389 -0800
@@ -5,7 +5,7 @@
 from multiprocessing import Process
 import socket, pickle, errno, struct, time
 
-from spt3g.core import G3FrameType, G3Frame
+from .libcore import G3FrameType, G3Frame
 
 class Subproc(Process):
     '''
@@ -85,7 +85,7 @@
                     while bytestoread > len(inbuf):
                         inbuf += self.queue[0].recv(bytestoread - len(inbuf))
                     self.queue[0].setblocking(False)
-                                
+
                     allout += pickle.loads(inbuf)
                     self.callsqueued -= 1
                     icount = 0 # Forward progress! Try again quick
@@ -129,7 +129,7 @@
             outbuf = pickle.dumps(out)
             outbuf = struct.pack('i', len(outbuf)) + outbuf
             self.queue[1].send(outbuf)
-                
+
             if frame.type == G3FrameType.EndProcessing:
                 return
 
diff -urN spt3g_software_orig/core/python/timestreamextensions.py spt3g_software/core/python/timestreamextensions.py
--- spt3g_software_orig/core/python/timestreamextensions.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/timestreamextensions.py	2021-11-12 00:48:05.974065885 -0800
@@ -1,6 +1,7 @@
 import numpy
-from spt3g.core import G3Timestream, DoubleVector, G3VectorDouble, G3TimestreamMap, G3Time, usefulfunc
-from spt3g.core import G3Units, log_fatal, log_warn
+from .libcore import G3Timestream, DoubleVector, G3VectorDouble, G3TimestreamMap, G3Time
+from .libcore import G3Units, log_fatal, log_warn
+from .funcconstruct import usefulfunc
 
 __all__ = ['concatenate_timestreams']
 
@@ -41,12 +42,12 @@
     out.stop = a.stop
     return out
 
-for x in ['__add__', '__and__', '__div__', '__divmod__', '__floordiv__', 
+for x in ['__add__', '__and__', '__div__', '__divmod__', '__floordiv__',
           '__mul__', '__neg__', '__or__', '__pow__', '__sub__', '__radd__',
           '__rdiv__', '__rdivmod__', '__rmod__', '__rmul__', '__rpow__',
           '__rsub__', '__rtruediv__', '__truediv__']:
     if x in numpy.ndarray.__dict__:
-        setattr(G3Timestream, x, 
+        setattr(G3Timestream, x,
                 lambda a, b, op=numpy.ndarray.__dict__[x]: numpybinarywrap(a, b, op))
 
 def numpyinplacebinarywrap(a, b, op):
@@ -55,16 +56,16 @@
     op(numpy.asarray(a), numpy.asarray(b))
     return a
 
-for x in ['__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__imod__', 
+for x in ['__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__imod__',
           '__imul__', '__ior__', '__ipow__', '__isub__', '__itruediv__']:
     if x in numpy.ndarray.__dict__:
-        setattr(G3Timestream, x, 
+        setattr(G3Timestream, x,
                 lambda a, b, op=numpy.ndarray.__dict__[x]: numpyinplacebinarywrap(a, b, op))
 
 # Bind some useful nativish binary operators
 for x in ['__eq__', '__ge__', '__gt__', '__le__', '__lt__', '__neq__']:
     if x in numpy.ndarray.__dict__:
-        setattr(G3Timestream, x, 
+        setattr(G3Timestream, x,
                 lambda a, b, op=x: numpy.ndarray.__dict__[op](numpy.asarray(a), numpy.asarray(b)))
 G3Timestream.mean = lambda a, *args, **kwargs: numpy.ndarray.mean(numpy.asarray(a), *args, **kwargs)
 G3Timestream.min = lambda a, *args, **kwargs: numpy.ndarray.min(numpy.asarray(a), *args, **kwargs)
diff -urN spt3g_software_orig/core/python/util.py spt3g_software/core/python/util.py
--- spt3g_software_orig/core/python/util.py	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/python/util.py	2021-11-12 00:49:03.513797270 -0800
@@ -1,4 +1,4 @@
-from spt3g.core import indexmod, pipesegment, G3FrameType, log_fatal, G3Reader, G3NetworkSender
+from .libcore import indexmod, pipesegment, G3FrameType, log_fatal, G3Reader, G3NetworkSender
 
 @indexmod
 def Delete(frame, keys=[], type=None):
@@ -45,7 +45,7 @@
 
     The frame data is stored in the variable names "frame".
 
-    If debug_start_func is not None, only starts a debug session when 
+    If debug_start_func is not None, only starts a debug session when
             debug_start_func(frame) == True
         '''
     if type is None or frame.type == type:
@@ -160,7 +160,7 @@
             else:
                 self.metacache.append(frame)
             return []
-                    
+
 
 del indexmod
 del pipesegment
diff -urN spt3g_software_orig/core/src/python.cxx spt3g_software/core/src/python.cxx
--- spt3g_software_orig/core/src/python.cxx	2021-09-01 14:56:55.000000000 -0700
+++ spt3g_software/core/src/python.cxx	2021-11-12 06:40:17.563105350 -0800
@@ -68,7 +68,7 @@
 		    PyBytes_FromStringAndSize(&buffer[0], buffer.size()))));
 	}
 
-	static void setstate(boost::python::object obj,	
+	static void setstate(boost::python::object obj,
 	    boost::python::tuple state)
 	{
 		namespace bp = boost::python;
@@ -90,7 +90,7 @@
 
         for (auto i = keyvec.begin(); i != keyvec.end(); i++)
                 keys.append(*i);
- 
+
         return keys;
 }
 
@@ -365,7 +365,7 @@
 numpy_vector_infrastructure(std::complex<double>, cxdouble, "Zd");
 numpy_vector_infrastructure(std::complex<float>, cxfloat, "Zf");
 
-BOOST_PYTHON_MODULE(core)
+BOOST_PYTHON_MODULE(libcore)
 {
 	bp::docstring_options docopts(true, true, false);
 
@@ -513,7 +513,7 @@
 	  "\t  processing if returned by first module. Equivalent to [].\n")
 	    .def("_Add_", &G3Pipeline::Add, bp::arg("name")="")
 	    .def("Run", &G3Pipeline::Run,
-	      (bp::arg("profile")=false, bp::arg("graph")=false), 
+	      (bp::arg("profile")=false, bp::arg("graph")=false),
 	      "Run pipeline. If profile is True, print execution time "
 	      "statistics for each module when complete. If graph is True, "
 	      "stores control flow data that can be processed with GraphViz "
